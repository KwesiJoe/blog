---
title: "Software Engineering, or, Building Better Straight Jackets"
author: Lane Wagner
date: "2021-04-12"
categories: 
  - "clean-code"
images:
  - /img/800/design.webp
draft: true
---

**Don't you just love it** when you're at a family gathering and your aunt with zero tech knowledge asks you, "Oh, you're a software engineer, huh? So, you solve those impossible-looking mathematical problems all day, right?" or when your clueless cousin enquires, "So, you manage programmers? Just like a project manager?" Well, surprise, surprise! It's not all algorithms and people-management, folks. It's about building a resilient, adaptable environment, where new features are more welcome than that cousin at family reunions, bugs can be squashed without causing an apocalypse, and refactoring code doesn't mean taking the entire system to the chopping block.

## What Software Engineering Isn't

First things first, let's clear up some common misbeliefs. If you think software engineering is about solving brain-melting algorithmic problems, **hate to break it to you**, that's computer science. Sure, we use algorithms, but it's just one piece of the larger puzzle. It's like saying football is all about kicking a ball. Well, duh, but what about the strategy, teamwork, and fitness involved?

Now, what about the folks who think we're just glorified managers, handling programmers all day like a herder guiding a flock of sheep? _Not quite_, my dear friend. That's management, not engineering. Yes, we do have to keep the team coordinated, but the core of our job is managing the **chaos in the codebase**, not people. 

## The Real Purpose of Software Engineering

In my humble opinion, which is totally the right opinion, software engineering is all about creating a **robust, maintainable codebase**. Imagine building a bridge: you don't just want it to stand upright, but it needs to be durable, adaptable to weather changes, and easy to repair. 

What makes a good codebase, you ask? Well, it's like the Holy Grail of programming: a system where you can roll out new features without causing a system-wide riot, squash bugs without needing a system do-over, and refactor code without setting off a ticking time bomb. 

And let's not forget speed. **We're the roadrunners** of the tech world, folks. The ability to swiftly navigate the labyrinth of code, rolling out timely updates, and staying ahead of system hiccups is not just desired—it's downright essential. 

## The Misunderstood Power of C++

Speaking of speed, remember when C++ was crowned the language of gigachads? The belief was that its raw power compensates for the lack of safety. To put it politely, that's a steaming pile of _BS_. Even the most decked-out, nitrous-boosted cars have seat belts, right? 

## Building Better Safety Nets - Straight Jackets

Safety nets are not just for the circus folks—they're the bread and butter of good programming. Just look at Rust, a language that is more obsessed with safety than a paranoid security guard, and yet, it's seen as a beacon of brilliance. As the famous line goes in the Hitchhiker's Guide to the Galaxy, "It is said that despite its many glaring (and occasionally fatal) inaccuracies, the Hitchhiker's Guide to the Galaxy itself has outsold the Encyclopedia Galactica because it is slightly cheaper, and because it has the words 'DON'T PANIC' in large, friendly letters on the cover." In programming terms, we don't panic—we build safety nets.

But you know what? We can do better than safety nets. We need _straight jackets_. 

Hear me out. When I say 'straight jackets', I mean constructing frameworks and systems that constrain you, but in a good way—much like a straight jacket. These restraints ensure that you don't go off the rails, that you stay within the bounds of good practice and maintainable code. They protect you, your team, and ultimately your project from the chaos that might ensue should you take one wrong step into the abyss of bad coding habits.

For example, consider the concept of type safety in a language like TypeScript. You might feel it's a straight jacket at first, keeping you from freely using any type you like, anywhere you like. But this constraint actually saves you from the potential nightmare of runtime errors, which might occur if you've unknowingly used the wrong type. 

Building straight jackets is about creating self-checking mechanisms that catch small errors before they escalate into unmanageable crises. It's about constructing an environment where you can refactor fearlessly, knowing your tests will catch breaks before they occur. It's about making things "easy to do right and hard to do wrong".

## Conclusion

Wrapping up, let me remind you, the essence of software engineering isn't solving complex algorithms or managing people. It's about **building better straight jackets**—codebases that can bend without breaking, grow without groaning, and adapt without aching. It's about crafting code that’s easy to read, easy to write, easy to debug, easy to scale, and easy to change.

After all, we're not just programmers—we're architects of resilience, creating digital fortresses that can weather the storm of bugs, withstand the weight of new features, and hold up under the hammer of refactoring. 

So, next time your aunt asks about your job, tell her it's not just about managing people or solving complex problems—it's about **building straight jackets** for a world that thrives on chaos. And you're darn good at it.
